#version 430

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Particle structure matching C++ struct
struct Particle {
    vec3 position;     // Current position
    float life;        // Current life (0.0 to 1.0)
    vec3 velocity;     // Current velocity
    float size;        // Particle size
    vec4 color;        // Particle color (RGBA)
    vec3 acceleration; // Acceleration (gravity, forces)
    float startLife;   // Initial life value
    vec2 rotation;     // Rotation (angle, angular velocity)
    float mass;        // Particle mass
    float padding;     // Padding for alignment
};

// Emitter configuration structure
struct EmitterConfig {
    vec3 position;
    float padding1;
    vec3 positionVariance;
    float padding2;
    
    vec3 velocity;
    float padding3;
    vec3 velocityVariance;
    float padding4;
    
    vec3 acceleration;
    float padding5;
    vec3 accelerationVariance;
    float padding6;
    
    vec4 startColor;
    vec4 endColor;
    vec4 colorVariance;
    
    float startSize;
    float endSize;
    float sizeVariance;
    float padding7;
    
    float startLife;
    float lifeVariance;
    float emissionRate;
    float maxParticles;
    
    float mass;
    float massVariance;
    float padding8;
    float padding9;
    
    bool looping;
    bool worldSpace;
    float padding10;
    float padding11;
};

// Buffers
layout(std430, binding = 0) restrict buffer ParticleBuffer {
    Particle particles[];
};

layout(std140, binding = 0) uniform EmitterBuffer {
    EmitterConfig emitter;
};

// Uniforms
uniform float deltaTime;
uniform float time;

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Check bounds
    if (index >= particles.length()) return;
    
    Particle particle = particles[index];
    
    // Skip dead particles
    if (particle.life <= 0.0) return;
    
    // Update life
    particle.life -= deltaTime / particle.startLife;
    
    if (particle.life <= 0.0) {
        particle.life = 0.0;
        particles[index] = particle;
        return;
    }
    
    // Update physics
    particle.velocity += particle.acceleration * deltaTime;
    particle.position += particle.velocity * deltaTime;
    
    // Update rotation
    particle.rotation.x += particle.rotation.y * deltaTime;
    
    // Write back to buffer
    particles[index] = particle;
}
